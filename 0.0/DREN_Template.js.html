<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: DREN/Template.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: DREN/Template.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Tools = require('./Tools');

/**
 * @typedef {object} Linker
 * @description Used to handle references while parsing/jsoning Templates
 */

/**
 * @class Template
 * @description A Template is like a "partial" in other rendering engines. It can't be the top level markup, and thus, should not contain the &lt;html>, &lt;body> or &lt;head> tags, which should be in the Page file
 * @param {string} fileName The path to the Template ECT file
 * @param {object} content Parameters given to the template for rendering
 * @param {object} [options] Additionnal options
 */
const Template = function Template(filename, content, options){
	this.fileName = filename;
	this.options = options || {};
	this.content = content;
}

/**
 * @method fromJson
 * @description Parse the given object to a Template instance. The object should have been generated using {@link Template#toJson}.
 * @memberof Template
 * @static
 * @param {object} json The JSON to parse as Template
 * @param {Linker} linker Used to keep references between templates
 * @returns {Template} The parsed Template
 */
Template.fromJson = function fromJson(json, linker){
	if(isNA(linker)){
		linker = {};
	}
	if(linker[json.id]){
		return linker[json.id]
	}

	if(json.type != "template"){
		throw "";
	}

	function nestedTemplatesParse(object){
		var newObj = {};
		for(var k in object){
			var value = object[k];
			if(!isNA(value)){
				if(Template.testJson(value)){
					newObj[k] = Template.fromJson(value, linker);
				} 
				if(isNA(newObj[k])){
					switch(value.constructor.name){
						case "Template":{
							newObj[k] = Template.fromJson(value, linker);
						} break;

						case "Object":
						case "Array":{
							newObj[k] = nestedTemplatesParse(value);
						} break;

						default:{
							newObj[k] = value;
						} break;
					}
				}
			}
		}
		return newObj;
	}
	if(Template.testJson(json)){
		return new Template(json.fileName, json.options, nestedTemplatesParse(json.content));
	}
	return undefined;
}

/**
 * @method testJson
 * @description Check if given plain object seems to be a valid JSON of Template
 * @memberof Template
 * @static
 * @param {object} json The JSON to test
 * @returns {boolean} True if it seems ok, false otherwise
 */
Template.testJson = function(json){
	return json.type &amp;&amp; json.fileName &amp;&amp; json.options &amp;&amp; json.content &amp;&amp; json.id
}

/**
 * @method toJson
 * @description Converts the Template in a simple JSON object
 * @memberof Tempalte
 * @instance
 * @param {Linker} linker Used to keep references between templates
 * @returns {Template} The parsed Template
 */
Template.prototype.toJson = function toJson(linker){
	function nestedTemplatesToJson(object){
		var newObj = {};
		for(var k in object){
			var value = object[k];
			if(!isNA(value)){
				switch(value.constructor.name){
					case "Template":{
						newObj[k] = value.toJson(linker);
					} break;

					case "Object":{
						newObj[k] = nestedTemplatesToJson(value);
					} break;

					case "Array":{
						newObj[k] = value;
					} break;

					default:{
						newObj[k] = value;
					} break;
				}
			}
		}
		return newObj;
	}



	var linkerKeys = Object.keys(linker),
		linkerKeysLength = linkerKeys.length,
		i = -1,
		json = {
			type: "template"
		},
		id;
	while(++i &lt; linkerKeysLength){
		var linkerKey = linkerKeys[i],
			linkerItem = linker[linkerKey];
		if(linkerKey === this){
			sails.log.silly("==> Reusing reference " + linkerKey);
			json.id = linkerKey;
			return json;
		}
	}

	do {
		id = Tools.randomString(16)
	} while(linker[id]);
	linker[id] = this;
	return {
		type: "template",
		id: id,
		fileName: this.fileName,
		options: this.options,
		content: nestedTemplatesToJson(this.content)
	}
}

/**
 * @method render
 * @description Render each components to generate the response
 * @memberof Template
 * @instance
 * @param {Page} page Parent Page instance
 * @param {string} prefix String used to mark the path to the template
 * @param {Linker} linker Used to keep track of relations
 * @param {FailableCallback} callback Function to call afterwards with the result
 * @async
 * @returns {undefined} Async
 */
Template.prototype.render = function render(page, prefix, linker, callback){
	var self = this;

	function nestedTemplatesToRenders(object, cbR){
		Async.mapValues(object, function(value, key, cb){
			if(!isNA(value)){
				switch(value.constructor.name){
					case "Template":{
						var subk = prefix + '.' + key;
						value.render(page, subk, linker, function(err, data){
							cb(err, '&lt;div data-content-area="' + subk + '">' + data + '&lt;/div>');
						});
					} break;

					case "Object":{
						nestedTemplatesToRenders(value, cb);
					} break;

					case "Array":{
						cb(null, value);
					} break;

					default:{
						cb(null,value);
					} break;
				}
			}
		}, function(err, out){
			if(err){
				sails.log.error("Error during composition content of Template:", out, err);
			};
			cbR(err, !err ? out : page.errorMessage(err));
		});
	}

	nestedTemplatesToRenders(this.content, function(err, data){
		if(err){
			return callback(err, data);
		}
		sails.log.silly("Rendering " + self.fileName + " with ", data);
		Tools.engine("../"+self.fileName+".ect", data, function(err, out){
			if(err){
				sails.log.error("Error during render of Template:", data, err);
			};
			callback(err, !err ? out : page.errorMessage(err));
		});
	})
}

module.exports = Template;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Page.html">Page</a></li><li><a href="Template.html">Template</a></li></ul><h3>Namespaces</h3><ul><li><a href="PageDiff.html">PageDiff</a></li></ul><h3>Global</h3><ul><li><a href="global.html#pageDiff">pageDiff</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Tue Aug 16 2016 19:40:44 GMT-1000 (TAHT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
